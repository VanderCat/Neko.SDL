using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Neko.Sdl.CodeGen;

[Generator]
public class EventGenerator : IIncrementalGenerator
{
    private const string AttributeNamespace = "Neko.Sdl.CodeGen";
    private const string AttributeName = "GenEventAttribute";
    private const string FullyQualifiedAttributeName = $"{AttributeNamespace}.{AttributeName}";

    // The source code for the attribute we will inject into the user's compilation.
    private const string AttributeSourceCode = @"// <auto-generated/>
namespace Neko.Sdl.CodeGen
{
    [System.AttributeUsage(System.AttributeTargets.Struct)]
    public class GenEventAttribute : System.Attribute
    {
    }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Inject the [GenEvent] attribute into the user's compilation
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenEventAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        // 2. Create a provider that finds all structs decorated with our attribute
        IncrementalValuesProvider<StructDeclarationSyntax> structDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                // A quick filter for structs with at least one attribute
                predicate: static (s, _) => s is StructDeclarationSyntax { AttributeLists.Count: > 0 },
                // A transform to check if the struct has the correct attribute
                transform: static (ctx, _) => GetStructWithAttribute(ctx)
            )
            // Filter out any structs that didn't have the attribute
            .Where(static m => m is not null)!;

        // 3. Combine the struct syntax with the compilation
        IncrementalValueProvider<(Compilation, System.Collections.Immutable.ImmutableArray<StructDeclarationSyntax>)> compilationAndStructs =
            context.CompilationProvider.Combine(structDeclarations.Collect());

        // 4. Register the final source output
        context.RegisterSourceOutput(compilationAndStructs,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    /// <summary>
    /// This method is the second stage of the pipeline. It checks if the found struct
    /// actually has the [GenEvent] attribute.
    /// </summary>
    private static StructDeclarationSyntax? GetStructWithAttribute(GeneratorSyntaxContext context)
    {
        var structDeclarationSyntax = (StructDeclarationSyntax)context.Node;

        // Iterate through all attributes on the struct
        foreach (AttributeListSyntax attributeListSyntax in structDeclarationSyntax.AttributeLists)
        {
            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue; // Not a valid attribute
                }

                INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                string fullName = attributeContainingTypeSymbol.ToDisplayString();

                // Check if the attribute's full name matches our target attribute
                if (fullName == FullyQualifiedAttributeName)
                {
                    return structDeclarationSyntax;
                }
            }
        }
        return null;
    }

    /// <summary>
    /// This is the final step where we generate the source code.
    /// </summary>
    private static void Execute(Compilation compilation, System.Collections.Immutable.ImmutableArray<StructDeclarationSyntax> structs, SourceProductionContext context)
    {
        if (structs.IsDefaultOrEmpty)
        {
            return; // No structs found, do nothing.
        }

        // Get a distinct list of structs to process.
        // This is important because the provider can be called multiple times.
        var distinctStructs = structs.Distinct();

        foreach (var structSyntax in distinctStructs)
        {
            var semanticModel = compilation.GetSemanticModel(structSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(structSyntax) is not INamedTypeSymbol structSymbol)
            {
                continue;
            }

            // Get the necessary details from the struct's symbol
            string structName = structSymbol.Name;
            string structNamespace = structSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : structSymbol.ContainingNamespace.ToDisplayString();
                
            // --- Code Generation ---
            var sourceBuilder = new StringBuilder();

            // Start of file
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("#nullable enable");
            sourceBuilder.AppendLine();

            // Add required using statements
            sourceBuilder.AppendLine("using System.Runtime.CompilerServices;");
            sourceBuilder.AppendLine("using System.Text;");
            sourceBuilder.AppendLine("using Neko.Sdl.Video; // Assuming this namespace exists for Window and SDL_* functions");
            sourceBuilder.AppendLine();

            // Add namespace block
            if (!string.IsNullOrEmpty(structNamespace))
            {
                sourceBuilder.AppendLine($"namespace {structNamespace};");
                sourceBuilder.AppendLine();
            }

            // Add the partial struct definition
            // We assume the user has made their struct `partial`. A diagnostic could be added to warn them if not.
            sourceBuilder.AppendLine($"public unsafe partial struct {structName}");
            sourceBuilder.AppendLine("{");

            // Add the ToString() method
            sourceBuilder.Append(@"

    public override string ToString() {
        var len = SDL_GetEventDescription((SDL_Event*)Unsafe.AsPointer(ref this), null, 0);
        var buf = new byte[len+1];
        fixed(byte* bufPtr = buf)
            SDL_GetEventDescription((SDL_Event*)Unsafe.AsPointer(ref this), bufPtr, buf.Length);
        return Encoding.UTF8.GetString(buf);
    }
");

            // Add the AssociatedWindow property
            sourceBuilder.Append(@"
    /// <summary>
    /// Window associated with an event
    /// </summary>
    public Window? AssociatedWindow {
        get {
            var window = SDL_GetWindowFromEvent((SDL_Event*)Unsafe.AsPointer(ref this));
            if (window is null) return null;
            return Window.GetById(SDL_GetWindowID(window));
        }
    }
");
            sourceBuilder.AppendLine(@"
    public ref CommonEvent ToCommon() => ref Unsafe.AsRef<CommonEvent>(Unsafe.AsPointer(ref this));
    public ref Event ToEvent() => ref Unsafe.AsRef<Event>(Unsafe.AsPointer(ref this));
");

            // Close the struct and namespace
            sourceBuilder.AppendLine("}");

            // Add the generated source to the compilation
            context.AddSource($"{structNamespace}.{structName}.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }
    }
}
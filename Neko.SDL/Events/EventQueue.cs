using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Neko.Sdl.Events;

/// <summary>
/// Event queue management.
/// <br/><br/>
/// It's extremely common--often required--that an app deal with SDL's event queue. Almost all useful information about
/// interactions with the real world flow through here: the user interacting with the computer and app, hardware coming
/// and going, the system changing in some way, etc.
/// <br/><br/>
/// An app generally takes a moment, perhaps at the start of a new frame, to examine any events that have occurred since
/// the last time and process or ignore them. This is generally done by calling <see cref="Poll"/> in a loop until it
/// returns false (or, if using the main callbacks, events are provided one at a time in calls to
/// <see cref="EntryPoints.IApplication.Event"/> before the next call to SDL_AppIterate(); in this scenario, the app
/// does not call <see cref="Poll"/> at all).
/// <br/><br/>
/// There is other forms of control, too: <see cref="Peep"/> has more functionality at the cost of more complexity, and
/// <see cref="Wait"/> can block the process until something interesting happens, which might be beneficial for certain
/// types of programs on low-power hardware. One may also use Watch event to add a callback when new events arrive.
/// <br/><br/>
/// The app is free to generate their own events, too: <see cref="Push"/> allows the app to put events onto the queue
/// for later retrieval; <see cref="Register"/> can guarantee that these events have a type that isn't in use by other
/// parts of the system.
/// </summary>
public static unsafe class EventQueue {
    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    private static SDLBool NativeFilter(IntPtr userdata, SDL_Event* @event) {
        try {
            var funcPin = new Pin<EventFilter>(userdata);
            if (funcPin.TryGetTarget(out var func))
                return func(ref Unsafe.AsRef<Event>(@event));
        }
        catch (Exception e) {
            Log.Error(0, e.ToString());
        }
        return true;
    }

    private static readonly Dictionary<EventFilter, IntPtr> _actionPin = new();
   
    /// <summary>
    /// Watch event added to the event queue
    /// </summary>
    /// <remarks>
    /// filter will be called when an event happens, and its return value is ignored.
    /// <br/><br/>
    /// WARNING: Be very careful of what you do in the event filter function, as it may run in a different thread!
    /// <br/><br/>
    /// If the quit event is generated by a signal (e.g. SIGINT), it will bypass the internal queue and be delivered to
    /// the watch callback immediately, and arrive at the next event poll.
    /// <br/><br/>
    /// Note: the callback is called for events posted by the user through <see cref="Push"/>, but not for disabled
    /// events, nor for events by a filter callback set with <see cref="Filter"/>, nor for events posted by the user
    /// through <see cref="Peep"/>.
    /// </remarks>
    public static event EventFilter Watch {
        add => SDL_AddEventWatch(&NativeFilter, _actionPin[value] = value.Pin(GCHandleType.Normal).Pointer).ThrowIfError();
        remove {
            if (!_actionPin.ContainsKey(value))
                return;
            _actionPin.Remove(value, out var userdata);
            SDL_RemoveEventWatch(&NativeFilter, userdata);
        }
    }

    /// <summary>
    /// A filter to process all events before they are added to the internal event queue
    /// </summary>
    /// <remarks>
    /// If you just want to see events without modifying them or preventing them from being queued, you should use
    /// <see cref="Watch"/> instead.
    ///
    /// If the filter function returns true when called, then the event will be added to the internal queue. If it
    /// returns false, then the event will be dropped from the queue, but the internal state will still be updated. This
    /// allows selective filtering of dynamically arriving events.
    ///
    /// WARNING: Be very careful of what you do in the event filter function, as it may run in a different thread!
    /// The exception is handling of <see cref="Events.EventType.WindowExposed"/>, which is guaranteed to be sent from
    /// the OS on the main thread and you are expected to redraw your window in response to this event.
    ///
    /// On platforms that support it, if the quit event is generated by an interrupt signal (e.g. pressing Ctrl-C), it
    /// will be delivered to the application at the next event poll.
    ///
    /// Note: Disabled events never make it to the event filter function; see <see cref="Enabled"/>.
    ///
    /// Note: Events pushed onto the queue with <see cref="Push"/> get passed through the event filter, but events
    /// pushed onto the queue with <see cref="Peep"/> do not.
    /// </remarks>
    public static EventFilter? EventFilter {
        get {
            if (_eventFilterPin is null)
                return null;
            return _eventFilterPin.Target;
        }
        set {
            if (_eventFilterPin is not null)
                _eventFilterPin.Dispose();
            if (value is null) {
                _eventFilterPin = null;
                SDL_SetEventFilter(null, 0);
                return;
            }
            _eventFilterPin = value.Pin(GCHandleType.Normal);
            SDL_SetEventFilter(&NativeFilter, _eventFilterPin.Pointer);
        }
    }

    private static Pin<EventFilter>? _eventFilterPin;

    /// <summary>
    /// Run a specific filter function on the current event queue, removing any events for which the filter returns
    /// false
    /// </summary>
    /// <remarks>
    /// See <see cref="EventFilter"/> for more information. Unlike <see cref="EventFilter"/>, this function does not
    /// change the filter permanently, it only uses the supplied filter until this function returns
    /// </remarks>
    public static void Filter(EventFilter filter) {
        using var pin = filter.Pin(GCHandleType.Normal);
        SDL_FilterEvents(&NativeFilter, pin.Pointer);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="eventType"></param>
    /// <returns></returns>
    public static bool Enabled(EventType eventType) => SDL_EventEnabled((SDL_EventType)eventType);
    public static void SetEnabled(EventType eventType, bool enabled) => SDL_SetEventEnabled((SDL_EventType)eventType, enabled);
    /// <summary>
    /// Clear events of a specific type from the event queue
    /// </summary>
    /// <param name="eventType">the type of event to be cleared; see <see cref="EventType"/> for details</param>
    /// <remarks>
    /// This will unconditionally remove any events from the queue that match type. If you need to remove a range of
    /// event types, use <see cref="Flush(EventType, EventType)"/> instead.
    /// <br/><br/>
    /// It's also normal to just ignore events you don't care about in your event loop without calling this function.
    /// <br/><br/>
    /// This function only affects currently queued events. If you want to make sure that all pending OS events are
    /// flushed, you can call <see cref="Pump"/> on the main thread immediately before the flush call.
    /// <br/><br/>
    /// If you have user events with custom data that needs to be freed, you should use <see cref="Peep"/> to remove and
    /// clean up those events before calling this function.
    /// </remarks>
    public static void Flush(EventType eventType) => SDL_FlushEvent((SDL_EventType)eventType);
    
    /// <summary>
    /// Clear events of a range of types from the event queue
    /// </summary>
    /// <param name="from">the low end of event type to be cleared, inclusive; see <see cref="EventType"/> for details</param>
    /// <param name="to">the high end of event type to be cleared, inclusive; see <see cref="EventType"/> for details</param>
    /// <remarks>
    /// This will unconditionally remove any events from the queue that are in the range of minType to maxType,
    /// inclusive. If you need to remove a single event type, use <see cref="Flush(EventType)"/> instead.
    /// <br/><br/>
    /// It's also normal to just ignore events you don't care about in your event loop without calling this function.
    /// <br/><br/>
    /// This function only affects currently queued events. If you want to make sure that all pending OS events are
    /// flushed, you can call <see cref="Pump"/> on the main thread immediately before the flush call.
    /// </remarks>
    public static void Flush(EventType from, EventType to) => SDL_FlushEvents((SDL_EventType)from, (SDL_EventType)to);

    /// <summary>
    /// Check for the existence of a certain event type in the event queue
    /// </summary>
    /// <param name="eventType">the type of event to be queried</param>
    /// <returns>true if events matching type are present, or false if events matching type are not present</returns>
    /// <remarks>If you need to check for a range of event types, use <see cref="HasEvents"/> instead.</remarks>
    public static bool HasEvent(EventType eventType) => SDL_HasEvent((SDL_EventType)eventType);
    
    /// <summary>
    /// Check for the existence of a certain event type in the event queue
    /// </summary>
    /// <param name="from">the low end of event type to be queried, inclusive</param>
    /// <param name="to">the high end of event type to be queried, inclusive</param>
    /// <returns>true if events with type >= minType and <= maxType are present, or false if not</returns>
    /// <remarks>If you need to check for a single event type, use <see cref="HasEvent"/> instead.</remarks>
    public static bool HasEvents(EventType from, EventType to) => SDL_HasEvents((uint)from, (uint)to);

    public static Event[] Peep(EventAction action = EventAction.Peek, int numevents = 0, EventType minType = EventType.First, EventType maxType = EventType.Last) {
        var len = numevents;
        if (len == 0)
            len = SDL_PeepEvents(null, 0, (SDL_EventAction)action, (uint)minType, (uint)maxType);
        var buffer = new Event[len];
        fixed (Event* bufferPtr = buffer) {
            var success = SDL_PeepEvents((SDL_Event*)bufferPtr, len, (SDL_EventAction)action, (uint)minType,
                (uint)maxType);
            if (success == -1)
                throw new SdlException();
        }

        return buffer;
    }

    /// <summary>
    /// Pump the event loop, gathering events from the input devices
    /// </summary>
    /// <remarks>
    /// This function updates the event queue and internal input device state.
    /// <br/><br/>
    /// <see cref="Pump"/> gathers all the pending input information from devices and places it in the event queue.
    /// Without calls to <see cref="Pump"/> no events would ever be placed on the queue. Often the need for calls to
    /// <see cref="Pump"/> is hidden from the user since <see cref="Poll"/> and <see cref="Wait"/> implicitly call
    /// <see cref="Pump"/>. However, if you are not polling or waiting for events (e.g. you are filtering them), then
    /// you must call <see cref="Pump"/> to force an event queue update.
    /// </remarks>
    public static void Pump() => SDL_PumpEvents();

    /// <summary>
    /// Poll for currently pending events
    /// </summary>
    /// <param name="event">the SDL_Event structure to be filled with the next event from the queue</param>
    /// <returns>true if this got an event or false if there are none available</returns>
    /// <remarks>
    /// The next event is removed from the queue and stored in the <see cref="Event"/> structure pointed to by event.
    /// The true returned refers to this event, immediately stored in the SDL Event structure -- not an event to follow.
    /// <br/><br/>
    /// As this function may implicitly call <see cref="Pump"/>, you can only call this function in the thread that set
    /// the video mode.
    /// <br/><br/>
    /// <see cref="Poll(ref Event)"/> is the favored way of receiving system events since it can be done from the main
    /// loop and does not suspend the main loop while waiting on an event to be posted.
    /// <br/><br/>
    /// The common practice is to fully process the event queue once every frame, usually as a first step before
    /// updating the game's state.
    /// <br/><br/>
    /// Note that Windows (and possibly other platforms) has a quirk about how it handles events while dragging/resizing
    /// a window, which can cause this function to block for significant amounts of time. Technical explanations and
    /// solutions are discussed on the wiki:
    /// <br/><br/>
    /// https://wiki.libsdl.org/SDL3/AppFreezeDuringDrag
    /// </remarks>
    /// <example>
    /// <code>
    /// while (game_is_still_running) {
    ///     Event event = new Event();
    ///     while (EventQueue.Poll(ref event)) {  // poll until all events are handled!
    ///         // decide what to do with this event.
    ///     }
    ///     // update game state, draw the current frame
    /// }
    /// </code>
    /// </example>
    public static bool Poll(ref Event @event) => SDL_PollEvent((SDL_Event*)Unsafe.AsPointer(ref @event));
    
    /// <summary>
    /// Poll for currently pending events
    /// </summary>
    /// <returns>true if this got an event or false if there are none available</returns>
    /// <remarks>
    /// It simply returns true if there is an event in the queue, but will not remove it from the queue. For more
    /// information see <see cref="Poll(ref Event)"/>
    /// </remarks>
    public static bool Poll() => SDL_PollEvent(null);

    /// <summary>
    /// Add an event to the event queue.
    /// </summary>
    /// <param name="event"> the <see cref="Event"/> to be added to the queue</param>
    /// <remarks>
    /// The event queue can actually be used as a two way communication channel. Not only can events be read from the
    /// queue, but the user can also push their own events onto it. event is a pointer to the event structure you wish
    /// to push onto the queue. The event is copied into the queue, and the caller may dispose of the memory pointed to
    /// after <see cref="Push"/> returns.
    /// <br/><br/>
    /// Note: Pushing device input events onto the queue doesn't modify the state of the device within SDL.
    /// <br/><br/>
    /// Note: Events pushed onto the queue with <see cref="Push"/> get passed through the event filter but events added
    /// with <see cref="Peep"/> do not.
    /// <br/><br/>
    /// For pushing application-specific events, please use <see cref="Register"/> to get an event type that does not
    /// conflict with other code that also wants its own custom event types.
    /// </remarks>
    public static void Push(ref Event @event) => SDL_PushEvent((SDL_Event*)Unsafe.AsPointer(ref @event)).ThrowIfError();

    /// <summary>
    /// Allocate a set of user-defined events, and return the beginning event number for that set of events
    /// </summary>
    /// <param name="numevents">the number of events to be allocated</param>
    /// <returns>
    /// the beginning event number, or 0 if numevents is invalid or if there are not enough user-defined events left
    /// </returns>
    public static EventType Register(int numevents) => (EventType)SDL_RegisterEvents(numevents);

    /// <summary>
    /// Wait indefinitely for the next available event
    /// </summary>
    /// <param name="event">the <see cref="Event"/> structure to be filled in with the next event from the queue</param>
    /// <remarks>
    /// The next event is removed from the queue and stored in the <see cref="Event"/> structure pointed to by event.
    /// <br/><br/>
    /// As this function may implicitly call <see cref="Pump"/>, you can only call this function in the thread that
    /// initialized the video subsystem.
    /// </remarks>
    public static void Wait(ref Event @event) => SDL_WaitEvent((SDL_Event*)Unsafe.AsPointer(ref @event)).ThrowIfError();

    /// <summary>
    /// Wait indefinitely for the next available event
    /// </summary>
    /// <remarks>
    /// As this function may implicitly call <see cref="Pump"/>, you can only call this function in the thread that
    /// initialized the video subsystem.
    /// </remarks>
    public static void Wait() => SDL_WaitEvent(null);
    
    /// <summary>
    /// Wait indefinitely for the next available event
    /// </summary>
    /// <param name="event">the <see cref="Event"/> structure to be filled in with the next event from the queue</param>
    /// <param name="timeoutMs">the maximum number of milliseconds to wait for the next available event</param>
    /// <remarks>
    /// The next event is removed from the queue and stored in the <see cref="Event"/> structure pointed to by event.
    /// <br/><br/>
    /// As this function may implicitly call <see cref="Pump"/>, you can only call this function in the thread that
    /// initialized the video subsystem.
    /// <br/><br/>
    /// </remarks>
    public static void Wait(ref Event @event, int timeoutMs) => 
        SDL_WaitEventTimeout((SDL_Event*)Unsafe.AsPointer(ref @event), timeoutMs).ThrowIfError();

    /// <summary>
    /// Wait indefinitely for the next available event
    /// </summary>
    /// <param name="timeoutMs">the maximum number of milliseconds to wait for the next available event</param>
    /// <remarks>
    /// As this function may implicitly call <see cref="Pump"/>, you can only call this function in the thread that
    /// initialized the video subsystem.
    /// <br/><br/>
    /// The timeout is not guaranteed, the actual wait time could be longer due to system scheduling.
    /// </remarks>
    public static void Wait(int timeoutMs) => SDL_WaitEventTimeout(null, timeoutMs);
}